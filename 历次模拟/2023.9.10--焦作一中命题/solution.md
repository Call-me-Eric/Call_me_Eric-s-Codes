# solution

## T1.heart

### 算法一

爆搜/状压/模拟。

可以获得 $20pts$ 。

### 算法二

随机化/网络流/调整法。

可以获得 $40$ ~ $60pts$ 。

### 算法三 

当 $k=\max(n,m)$ 时，我们直接每次循环位移一位就可构造。

期望得分 $70pts$ 。

### 算法四

设空格最多的行或列的空格数为 $A$ ，则答案显然 $\geq A$ 。

我们接下来说明，存在一种构造使得答案取到 $A$ ：

按任意顺序考虑空格子，设当前格子所在行中编号最小的没有填过的颜色编号为 $a$，列中的为 $b$ 。

- 如果 $a=b$ ，我们就在这个格子填上 $a$ 。
- 否则，我们不妨认为 $a<b$ ，那么我们就在这个格子填上 $a$ ，但是当前列可能本来就有 $a$ ，所以我们可以把原本的 $a$ 换成 $b$ ，然后可能那一行本来有 $b$，我们就再继续换成 $a$ …… 直到不矛盾为止。显然这样子迭代不会访问到相同的行或列，否则必然会产生矛盾。

可以证明这样构造答案不会超过 $A$ 。

时间复杂度 $O(Tnm(n+m)$

## T2.together

### 算法一

注意到题目中的树就是笛卡尔树，而询问的就是每个节点的祖先链和，这又等价于每个节点的 $b_x\times (r_x-l_x+1)$ 之和，$l_x,r_x$ 是节点对应的区间。

暴力求，期望得分 $10pts$ 。

### 算法二

注意到上述贡献可以递归求解，因此可以用区间 $dp$ 预处理。

然后做一个二维前缀和就可以得到第二问的答案。

复杂度 $O(n^2+m)$ 。

期望得分 $40pts$ 。

### 算法三

关键性质：

> 枚举原序列笛卡尔树上的节点 $x$，其在询问区间的笛卡尔树上的区间为 $[max(L,l_x),min(R,r_x)]$ 

证明比较是自然的。

那么考虑第一种询问，等价于询问满足 $i\in[L,R]$ 的 $b_i(-max(L,l_i)+min(R,r_i)+1)$ 。

即为 

$$\sum\limits_{i=L}^Rb_i(\min(R,r_i)-max(L,l_i)+1)$$

$$\sum\limits_{i=L}^Rb_i\min(R,r_i)-\sum\limits_{i=L}^Rb_i\max(L,l_i)+\sum\limits_{i=L}^Rb_i$$

分成三部分求解，第三部分做前缀和即可，前两种询问是对称的，我们只考虑第一种：

$$\sum\limits_{i=L}^Rb_i\min(R,r_i)=\sum\limits_{i=L}^Rb_i[r_i\leq R]r_i+\sum\limits_{i=L}^Rb_i[r_i>R]R$$

离线扫描线即可。

#### 算法五

考虑拓展上面的式子。

$$\sum\limits_{s=L}^R\sum\limits_{t=s}^R\sum\limits_{i=s}^tb_i(\min(t,r_i)-\max(s,l_i)+1)$$

$$\sum\limits_{s=L}^R\sum\limits_{t=s}^R\sum\limits_{i=s}^tb_i\min(t,r_i)-\sum\limits_{s=L}^R\sum\limits_{t=s}^R\sum\limits_{i=s}^tb_i\max(s,l_i)+\sum\limits_{s=L}^R\sum\limits_{t=s}^R\sum\limits_{i=s}^tb_i$$

$$\sum\limits_{i=L}^Rb_i\sum\limits_{s=L}^i\sum\limits_{t=i}^R\min(t,r_i)-\sum\limits_{i=L}^Rb_i\sum\limits_{s=L}^i\sum\limits_{t=i}^R\max(s,l_i)+\sum\limits_{i=L}^Rb_i(i-L+1)(R-i+1)$$​

$$\sum\limits_{i=L}^Rb_i(i-L+1)\sum\limits_{t=i}^R\min(t,r_i)-\sum\limits_{i=L}^Rb_i(R-i+1)\sum\limits_{s=L}^i\max(s,l_i)+\sum\limits_{i=L}^Rb_i(i-L+1)(R-i+1)$$

先考虑第三部分：

$$\sum\limits_{i=L}^Rb_i(i-L+1)(R-i+1)=\sum\limits_{i=L}^Rb_iiR-b_i(L-1)R-b_ii(i-1)+b_i(L-1)(i-1)$$

维护 $\sum b_ii,\sum b_i,\sum b_ii(i-1),\sum b_i(i-1)$ 即可。

前两部分是类似的，考虑第一部分：

$$\sum\limits_{i=L}^Rb_i(i-L+1)\sum\limits_{t=i}^R\min(t,r_i)$$

$$\sum\limits_{i=L}^Rb_i(i-L+1)([r_i\leq R](\frac{1}{2}(i+r_i)(r_i-i+1)+r_i(R-r_i))+[r_i>R](\frac{1}{2}(i+R)(R-i+1)))$$

发现只和 $r_i,R$ 的关系有关，因此还是一个扫描线就可以解决。

常数可能有点大。

复杂度 $O((n+m)\log n)$  。

## T3.cumulonimbus

### 算法一

爆搜分布，然后爆搜求 $C(Q)$，期望得分 $10pts$ 。

### 算法二

注意到求解 $C(Q)$ 和爆搜是独立的，我们可以先预处理每个状态的 $C(Q)$ ，乘上概率再求和即可。

可以用状压 $DP$ ，复杂度 $O(2^{nm}n^3)$ 但是跑不满。

期望得分 $30pts$ 。

### 算法三

按行状压，压一下每一列上面时候还剩有节点。

复杂度 $O(4^{n})$

期望得分 $40pts$ 。

### 算法四

考虑一个性质：

> 如果两朵云可以合并，就连一条边，那么对于这个图中一个大小为 $x$ 的连通块，最后就会剩下 $x\bmod 2$ 个点。

证明就考虑每次选两个点，然后把两点间路径的匹配状态翻转。

那么我们爆搜这图的连通块划分，复杂度是 $n+m$ 的分拆数。

可以获得 $60pts$ 。

### 算法五

考虑改变一下建图，如果位置 $(i,j)$ 有一朵云，就在行 $i$ 和列 $j$ 之间连一条边。

那么结论就变成了每个连通块边数的奇偶性。

考虑状压 $dp$ ，设 $f[S][0/1]$ 为点集 $S$ 连通，且连通块内的边数 $\bmod 2=0/1$ 的概率。

转移时，用任意填的方案数，减掉不连通的方案数，而不连通的方案数可以钦定一个子集连通块，然后剩下的随便连。

然后设 $dp_S$ 为考虑了点集 $S$ 内部的点和边，各个连通块的边数奇偶性之和的期望值，转移时枚举一个新的连通块并起来即可。

瓶颈在于枚举子集，复杂度 $O(T3^{n+m})$，可能略微卡常。

## T4.summer

### 算法一

暴力询问，期望得分 $20pts$ 。

### 算法二

注意到 $dis_{x,u}+dis_{u,1}\geq dis_{x,1}$ ，这等价于 $u$ 在 $x$ 到 $1$ 的路径上。

因此 $f(u)$ 最小的点一定是所有点到 $1$ 的路径的交中最深的节点。

这个点实际上就是点集内所有点的 $lca$ 。

这又等价于点集内 $dfs$ 序最小的点和最大的点的 $lca$ .

因此，我们可以用线段树维护区间内 $dfs$ 序最小的点，用平衡树维护 $dfs$ 序，就可以求出最小的点和最大的点，剩下来就只需要求出这两个点的 $lca$ 。

$lct$ 显然可以直接做，但是我们还是希望用平衡树解决。

考虑经典的 $O(1)lca$ 做法，维护欧拉序，以及每个节点的深度，那么 $lca$ 就是区间内深度最小的点。

支持插入，区间加，区间最值就好了，平衡树可以轻松维护。

复杂度 $O(n\log ^2n)$ 。

### 算法三

$T=0$ 时，离线下来树剖就好了。 

### 算法四

上述做法瓶颈在于维护 $dfs$ 序。

我们有一个直观的想法，当在某两个点之间插入一个新的点时，把这个点的 $dfs$ 序赋成这两个点的 $dfs$ 序的平均数。

当然插入的点过多时就无法保证精度了，但是树随机的时候是正确的。

期望得分 $70pts$ 。

### 算法五

上述做法问题在于我们无法保证精度，因为树的高度可能很高。

但是只要我们把树的高度变成 $\log n$ 不就好了吗。

我们再开一个非旋转，且高度为 $\log n$ 的平衡树，动态地维护实数 $dfs$ 序值就可以了。

这样就可以 $O(1)$ 查询 $dfs$ 序，复杂度 $O(n\log n)$ 。

