## D2T1

建立 $m$ 个虚点 $S_1,\cdots,S_m$ ， $S_i$ 与 $x\in S_i$ 连边。

任取图中一个简单环即为答案。

## D2T2

注意到 $F(p)=p+1$ 还是比较好看的。

设 $G=F*\mu*id^{-1}$ ，其中 $*$ 是狄利克雷卷积，$id^{-1}$ 是函数 $id(n)=n$ 的逆元。显然 $G(p)=0$ ，因此 $G$ 只在 powerful number 处取非零值。

因此 $F=G*(id*I)$ ，其中 $I(n)=1$ 。设 $H=id*I$ 。
$$
\sum_{i=1}^n F(i)=\sum_{i=1}^n \sum_{j|i}G(j)H(i/j)=\sum_{j=1}^n G(j)\sum_{i=1}^{n/j}H(i)
$$
因为 powerful number 只有 $O(\sqrt n)$ 个，所以 $j$ 可以暴力枚举，只要快速计算 $H$ 的前缀和。
$$
\sum_{i=1}^n H(i)=\sum_{i=1}^n \sum_{j|i}j=\sum_{j=1}^n j\lfloor n/j\rfloor
$$
整除分块即可。

设 $P$ 是 $\le n$ 的 powerful number 集合，复杂度是 $\sum_{x\in P}\sqrt{n/x}=O(\sqrt n\log n)$ 。

## D2T3

进行若干轮之后，不难发现，两个点之间有边当且仅当原树上两个点之间的路径上的点全都被删除了。

设 $w_i$ 表示第 $i$ 个点在第几次被删除。那么对于 $w_x=w_y$ ，必须有 $\exists z\in path(x,y),w_z>w_x$ 。

注意到我们一定可以构造出 $\lceil\log n\rceil$ 次的方案：直接按照点分树的深度进行标号即可。

自底向上做，考虑一个子树会对外面产生什么影响。对于 $x$ ，如果 $x$ 到根的路径上没有比 $w_x$ 更大的标号，就称 $w_x$ 没有被挡住。显然我们只关心哪些标号没有被挡住。

考虑自底向上 dp ，设 $dp_{i,s}$ 表示做完了 $i$ 的子树，没被挡住的标号集合是 $s$ ，是否合法。那么 $s$ 只有 $2^{\log n}=O(n)$ 种状态，可以引出一个 $O(\text{poly} (n))$ 的做法。

进一步可以注意到，事实上只有最小的 $s$ 是有用的，而合并也很简单，所以不难优化到 $O(n\log n)$ 。

## D2T4

如果没有定义这种奇怪的匹配方式，那么显然就是一个 exkmp 板题。

我们不妨先看看 kmp 能不能用在这种匹配方式上。

发现真可以啊！我们仍然可以像 kmp 那样定义 nxt 数组，该怎么跳还是怎么跳。

那如果再像 exkmp 那样定义 ext 数组呢？发现也没什么问题。

那就只需要用一棵主席树来无脑维护区间 rank 即可。

