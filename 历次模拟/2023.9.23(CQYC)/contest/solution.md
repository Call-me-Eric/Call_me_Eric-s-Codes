# Solution

## arisu

返回值为错误，当且仅当有一个数出现在 $ n $ 前面，且后面连续 $ k $ 个数都比它小。  
直接计算是困难的，我们考虑计算返回值正确的排列数，记 $ f_i $ 为长度为 $ i $ 的排列，且没有提前返回的排列数。  
那么   
$ ans = n! - \sum_{i = 0} ^ {n - 1} f_i \binom {n - 1} {i} (n - i - 1)! $  

表示枚举最大值 $n$ 前面有多少数，前面 $i$ 个数不能提前返回值， $n$ 后面的数可以随便排

关于 $ f_i $ 的递推式也比较显然  
$ f_i = \sum_{j = 1} ^ {k} f_{i - j} \binom {i - 1} {j - 1} (j - 1)! $  
$ \quad = (i - 1)! \sum_{j = 1} ^ {k} \frac {f_{i - j}} {(i - j)!} $  
这个式子可以前缀和优化做到线性，计算答案也是线性的，总复杂度 $ O(n) $
<div STYLE="page-break-after: always;"></div>

## band
直接计算函数极其不现实，考虑函数的组合意义来尝试从其他角度计数。
$$
f(T)=\frac{\sum_{e \in E(T)} f(T_u(e)) \times f(T_v(e))}{n}
$$
我们为了使这个函数具有组合意义，可以尝试将 $\frac{1}{n}$ 看成一种概率，但从所有边中选取一条的概率是 $\frac{1}{n-1}$，不对。发现树上不好加边，但可以加点，因此我们尝试将边转成点，这时点数 $n+(n-1)$ 依然不对，我们将 $n-1$ 乘上 $P$ ，即对于每个由边转换来的点，我们给其增加 $P-1$ 个儿子，这样总点数 $\mod P$ 意义下就是 $n$。由此我们可以将乘的 $\frac{1}{n}$ 看成是从所有点中等概率随机选择一个的概率。  
  
我们将由边转换来的点称为“边点”。则 $f(T)$ 等价于对全树总共 $n + P \times (n-1)$ 个点进行随机排列，所有边点都在其所有邻居前面的概率。  
  
我们将限制作为边连出来，会发现这棵上的边有上有下，我们考虑容斥，将所有向上的边改为向下或者没有限制，即没有边，容斥系数为改为向下的边的条数。现在我们的树可以看成是有一些无向边连接了一些外向树组成，于是我们得到了一个 DP:  
  
记 $f_{i,j}$ 为考虑了 $i$ 及其子树，向下构成的外向树的大小模意义下为 $j$，$i$ 是在最终排列中是里面最靠前的点的方案数，考虑我们需要哪些转移：  
对于一个普通点 $x$：我们要做的就是树形背包，设当前 $x$ 外向树大小 $i$，当前枚举的儿子为 $v$，其外向树大小为 $j$，则： 
$$
f_{x,i+j}'-=f_{x,i} \times f_{v,j}
$$
这里因为 $x$ 是普通点，所以我们在选择边向下的时候要乘上容斥系数。  
而如果我们选择不连向 $v$，则：
$$
f_{x,i}'+=f_{x,i} \times \sum_{j=1}^{siz_v}f_{v,j}
$$
由于 $x$ 要排在最前面，所以在转移结束之后要给每一个值乘上一个 $\frac{1}{i}$。
边点新增的儿子都是叶子节点，不需要考虑。  
  
对于一个边点 $x$ 来说：他向儿子连的所有边在原图都是向下的，所以不需要容斥，然后发现枚举新增的 $P-1$ 个儿子进行转移并不会影响 $f$ 的值，因此可以不做。而对于唯一需要的转移，由于 $x$ 加上 $P-1$ 个儿子后在模意义下对 $siz$ 没有贡献。所以我们只需要对于每一个 $i$ 乘上 $\frac{1}{i}$。  
$$
f_{x,i}'=f_{v,i} \times \frac{1}{i}
$$

$$
ans=\sum_{i=1}^{n} f_{1,i}
$$
$O(n^2)$。
<div STYLE="page-break-after: always;"></div>

## hoshi
考虑最大生成森林的过程，每条边会 $(u, v)$ 会在 $u$ 和 $v$ 不联通时加入边集，那么只需要同时维护 $k$ 个边集，找到第一个使 $u$ 和 $v$ 不联通的边集，加入这条边就行。  
又发现，两个点的连通性必然是有一个前缀边集 $u$ 和 $v$ 联通，后面的都不联通，那么可以直接二分，复杂度 $O(nk + mlog{k})$ 。
<div STYLE="page-break-after: always;"></div>

## slime
考虑 k 只有一种的情况

我们先求出这个状态下，可重集 $S$ 中每种不同的数有几个，设 $x$ 出现了 $b[x]$ 次。然后我们考虑，假如一个区间中一个数 $x$ 出现了 $c[x]$ 次，那么我们需要在 $b[x]$ 中选 $c[x]$ 个进行排列，也就是 $b[x]^{\underline{c[x]}}$​次。这个在 $c[x]$ 加一或者减一的时候可以 $O(1)$ 维护出来，显然想到莫队。

接下来还有一个问题就是，我们求得是钦定了 $[l,r]$ 区间内选的数的方案数，还有剩下随机排列的方案数要乘上去。

令 $A = n + mk, L = r - l + 1$。

那么实际上要求的就是 $(A - L)^{\underline{n - L}} = \prod_{i = A - n + 1}^{A - L} i$ 这个可以对于每种 $k$ 预处理出来。

复杂度分析

首先其他部分都是不超过 $O((n + m)k + q\log k)$ 的，复杂度的瓶颈在莫队上。

假设对于每种 $k$，询问的次数分别为 $q_1, q_2, q_3,...,q_k$。

一次莫队的复杂度为 $O(n\sqrt{q})$，因此 $n\sum_i \sqrt{q_i}$。

运用权方和不等式可证，当所有 $q_i$ 相等时，上式取得最大值。

因此复杂度即为 $O(nk\sqrt{\frac{q}{k}}) = O(n\sqrt{qk})$，差不多能过。

标程写得比较丑，勿喷。
<div STYLE="page-break-after: always;"></div>