## Cards

如果之后要攻击 $t$ 次，那么加 $a$ 力量相当于多了 $at$ 伤害。因此我们DP后面还要攻击几次这样的总伤害，复杂度 $O(n^2)$。

## Meet

肉眼可见大概是有某条边分开这个树，然后两边分别取重心。

有一个经典的结论是每个点到重心的距离和可以每条边分开算：每条边会被经过min两边大小次。

那么比如你现在是 a 的父边分开了树，下面一条 x 到父亲边的贡献大概就是 $\min(sz[x],sz[a]-sz[x])$ 这样，那就是说如果 $sz[x]\le sz[a]/2$ 就贡献 $sz[x]$ 乘权值，否则 $sz[a]-sz[x]$ 乘权值。对于外面的子树分情况讨论：如果是 x 不在 a 的祖先链上贡献就是 $\min(sz[x],n-sz[a]-sz[x])$，否则它的 sz 里已经包含 a 了，贡献是 $\min(n-sz[x],sz[x]-sa[a])$。

接下来我们就可以大力维护这个东西了。在祖先链上的这个条件可以直接一边dfs一边维护，其他东西可以启发式合并或者线段树合并。

## Subseq

如果是DP本质不同子序列数量我们可以用序列自动机：每个位置往每个字符的下一次出现转移。

可以脑补出一个DP：我们每次选下一个字母转移，但保证转移中间塞不了一个新的上一个字符。就如果你现在 s[a]=x，你要往下一个 s[b]=y 转移，你要保证 a+1..b-1 没有 x，否则显然不是只出现一次的。此外如果你计划结尾你也要保证后头没有 x 了。

这为啥是对的？如果实际上方案是借用了某个 b 以后的 x，那么这个 x 后头接的 y 也得从 b 后头来，那么我们就可以归纳：b 开始的子序列已经保证是唯一出现的了。

## Sort

特别恶心的一个题。注意对拍。

首先容易看出我们每次是把全局最小值换到当前位置上，所以 $i=1$ 时我们会把最小值换自己头上。步数就是整个序列单调栈的长度。

设 $a_m$ 是全局最小值。

如果 $m=1$，第 $i$ 个元素的场景形如 a[2] a[3] ... a[i-1] a[1] (a[i])（括号的是当前正在操作的元素）。我们就是要找 a[2] ... a[i-1] a[1] 这个单调栈里有多少个 <a[i] 的元素。

当 $m>1$ 时，

+ 对于 $i\in [2,m]$：a[2] a[3] ... a[i-1] a[m] (a[i])
+ 对于 $i>m$：a[2] a[3] ... a[m-1] a[1] a[m+1] a[m+2] ... a[i-1] a[m] (a[i])（**）

类似维护单调栈（** 的维护方法就是不把 a[m] 塞进去，那就是每次pushback）然后二分，这样我们就可以做一个询问了。

假设目前已经 $m\ne 1$ ，我们在最后塞了一个新元素会发生什么。如果它不是最小值，你可以发现它压根不影响其他人操作的步数，和一个询问一样算一下自己的答案就行。

否则假设它是 $n$，对于 $i<m$ 的兄弟只是 a[m] 换成了 a[n] 步数不变，对于 $m\le i<n$ 的兄弟它们会需要 a[2] a[3] ... a[m-1] a[m] ... a[n-1]（中间省略一大坨）a[n] 这样一个单调栈里头 <a[i] 的元素个数。有一点好的是我们发现 a[m] 比后面省略的一坨都小，所以中间是啥都一样。我们还可以进一步简化写成 a[2] ... a[i-1] a[n] 单调栈里头 <a[i] 的元素个数，因为 i-1 肯定包起来 a[m] 了。我们在 i 的时候就记一下这个值，在这时候就能排上用场了。

如果目前 $m=1$ 遇到下一个最小值了就重建整个东西。

主要恶心的地方是要注意 a[2] 开头的那个单调栈和 a[1] 开头的那个单调栈不是同一个东西，然后和标 (**) 的那个栈也不是同一个栈。