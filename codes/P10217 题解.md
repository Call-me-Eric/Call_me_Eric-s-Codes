# 联合省选D1T1

## 题解

首先能够发现，所有 $x_i$ 同号，所有 $y_i$ 同号。

显然一直向一个方向走消耗的轮数是最少的。

那么就有 $\sum_{i = 0}^{n - 1}|x_i| = |\sum_{i = 0}^{n - 1}x_i|$（$y_i$ 同理）

我们不妨设进行了 $m$ 次移动能够到达。

然后发现，限制  
$$
\forall i \in [0,m - 1],|x'_i|+|y'_i|\le K\\
\iff\sum_{i = 0}^{m - 1}|x'_i|+\sum_{i = 0}^{m - 1}|y'_i|\le K\times m$$

而且还能够发现，其实有 $\sum_{i = 0}^{m - 1}|x'_i|=\sum_{i = 0}^{m - 1}x_{i\mod n} - X$（$y$ 同理）

于是你就能够将刚刚的判定式子变成这样：  
$$
|\sum_{i=0}^{m-1}x_{i\mod n}-X| + |\sum_{i=0}^{m-1}y_{i\mod n} - Y| \le m\times K
$$

发现这个式子不好判定。

先设函数 $fx(m) = \sum_{i=0}^{m-1}x_{i\mod n}$（$fy(m)$ 同理不再重复）

先将这个式子变变样子：

$$
fx(m) = \sum_{i=0}^{m-1}x_{i\mod n}\\
=\lfloor\frac{m}{n}\rfloor\sum_{i=0}^{n-1}x_i+\sum_{i=0}^{(m \mod n) - 1}x_i
$$

然后就有了显然的 $O(答案)$ 的暴力。

然后呢？

发现绝对值非常不好搞，想去掉。

可是有可能出现 $fx(m)\ge X$ 但是 $fx(m+1)< X$ 的情况。

归根结底是因为 $x_i$ **没有单调性！**

思路停下来了怎么办？

我们发现，虽然 $x_i$ 没有单调性，但是 $\sum_{i=0}^{n-1}x_i$ 的值是固定的。

设 $m=an+b,b<n,a,b\in \mathbb{N^+}$。

于是有

$$fx(m) = a\sum_{i=0}^{n-1}x_i+\sum_{i=0}^{b - 1}x_i$$

不难发现这个时候，如果 $b$ 是固定的，那么 $fx(an+b)$ 随着 $a$ 增加而单调变化。

于是我们枚举 $b$，尝试求出最小的 $a$ 满足上式。

那么在所有的 $b$ 中，最小的 $an+b$ 就是答案（当然如果都无解就彻底无解了）

设  
$$sX=\sum_{i=0}^{n - 1}x_i,sY=\sum_{i=0}^{n - 1}y_i$$  
$$u=X-\sum_{i=0}^{b - 1}x_i,v=Y-\sum_{i=0}^{b - 1}y_i$$

那么上式变为

$$|a\times sX - u| + |a\times sY - v|\le a\times n K + bK$$

设

$$
f1=\begin{cases}
1&a>\lfloor\frac{sX}{u}\rfloor\\
-1&a\le\lfloor\frac{sX}{u}\rfloor
\end{cases}
$$

$$
f2=\begin{cases}
1&a>\lfloor\frac{sY}{v}\rfloor\\
-1&a\le\lfloor\frac{sY}{v}\rfloor
\end{cases}
$$

则上式变为

$$
f1(a\times sX - u) + f2(a\times sY - v)\le a\times n K + bK\\
\iff a\times(f1\times sX+f2\times sY - n\times K)\le b\times K+f1\times u+f2\times v
$$

不难发现，$\lfloor\frac{sX}{u}\rfloor,\lfloor\frac{sY}{v}\rfloor$ 将 $a$ 的定义域 $[0,+\infin)$ 分成三部分，每一段的 $(f1,f2)$ 二元组都不相同，对应的式子也不尽相同。

每一段都在求，当 $a\in[l,r)$ 的时候，满足不等式 $a\times a_1\le b_1$ 的最小的 $a$（$a$ 可能无解）

然后你就做完了，全程所有变量没有超过 $O(nK)$，不需要使用 `__int128`。

## 代码

~~调了3h的赛时代码相当丑陋~~

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
bool stmemory;
namespace Call_me_Eric{
inline ll read(){
    ll x = 0, f = 1;char ch = getchar();
    while(!isdigit(ch)){if(ch == '-') f = -1;ch = getchar();}
    while(isdigit(ch)){x = (x << 1) + (x << 3) + (ch ^ 48);ch = getchar();}
    return x * f;
}
const ll maxn = 1e5 + 10, INF = 0x3f3f3f3f3f3f3f3f;
ll n, m, k, X, Y;
ll x[maxn], y[maxn];
ll sx[maxn], sy[maxn];
ll fx(ll u){return u / n * sx[n - 1] + sx[max(0ll,u % n - 1)];}
ll fy(ll u){return u / n * sy[n - 1] + sy[max(0ll,u % n - 1)];}
bool check(ll m){return abs(fx(m) - X) + abs(fy(m) - Y) <= m * k;}
ll calc(ll a,ll b,ll l,ll r){
    if(r < l)return INF;
    if(a == 0){return b >= 0 ? l : INF;}
    if(a > 0){
        ll x = floor(1.0 * b / a);
        if(x >= l)return l;
        else return INF;
    }
    else{
        ll x = ceil(1.0 * b / a);
        if(x <= r)return max(x,l);
        else return INF;
    }
}
void solve(){
    n = read(); k = read(); X = read(); Y = read();
    for(ll i = 0;i < n;i++){
        x[i] = read(); y[i] = read();
        if(i){sx[i] = sx[i - 1] + x[i];sy[i] = sy[i - 1] + y[i];}
        else {sx[i] = x[i];sy[i] = y[i];}
    }
    if(X == 0 && Y == 0){puts("0");return;}
    ll m = INF,res = INF, id = INF;
    for(ll i = 0;i < n;i++){
        ll ans = INF;
        ll sxx = i ? sx[i - 1] : 0;
        ll syy = i ? sy[i - 1] : 0;
        ll u = X - sxx, v = Y - syy;

        ll a = -1, b = -1;
        if(sx[n - 1] != 0)a = floor(1.0 * u / sx[n - 1]);
        if(sy[n - 1] != 0)b = floor(1.0 * v / sy[n - 1]);
        a = max(a,-1ll); b = max(b,-1ll);

        ll sX = sx[n - 1], sY = sy[n - 1];
        if(a > b){swap(a,b);swap(sX,sY);swap(u, v);}
        ll f1 = 1, f2 = 1, c, d;
        // printf("[%lld,%lld]\n",0ll,a);
        if(0ll <= a){
            f1 = 0 * sX > u ? 1 : -1;
            f2 = 0 * sY > v ? 1 : -1;
            c = -n * k + f1 * sX + f2 * sY, d = i * k + f1 * u + f2 * v;
            ans = min(ans,calc(c,d,0ll,a));
        }
        if(ans != INF){if(res > ans)res = ans,id = i;continue;}

        // printf("[%lld,%lld]\n",a + 1,b);
        if(a + 1 <= b){
            f1 = (a + 1) * sX > u ? 1 : -1;
            f2 = (a + 1) * sY > v ? 1 : -1;
            c = -n * k + f1 * sX + f2 * sY, d = i * k + f1 * u + f2 * v;
            ans = min(ans,calc(c,d,a + 1,b));
        }
        if(ans != INF){if(res > ans)res = ans,id = i;continue;}

        // printf("[%lld,%lld]\n",b+1,INF);
        if(b + 1 <= INF){
            f1 = (b + 1) * sX > u ? 1 : -1;
            f2 = (b + 1) * sY > v ? 1 : -1;
            c = -n * k + f1 * sX + f2 * sY, d = i * k + f1 * u + f2 * v;
            ans = min(ans,calc(c,d,b + 1,INF));
        }
        if(ans != INF){if(res > ans)res = ans,id = i;continue;}

    }
    m = res * n + id;
    if(res == INF)puts("-1");
    else{printf("%lld\n",m);}
    // printf("check = %d\n",);
    // printf("res = %lld\n",res);
    return;
}
void main(){ll T = read();while(T--){solve();}return;}
};
bool edmemory;
signed main(){
    auto stclock = clock();
    Call_me_Eric::main();
    auto edclock = clock();
    cerr << (&stmemory - &edmemory) / 1024.0 / 1024.0 << " Mib cost.\n";
    cerr << (edclock - stclock) * 1.0 / CLOCKS_PER_SEC << " Sec cost.\n";
    return 0;
}
```
